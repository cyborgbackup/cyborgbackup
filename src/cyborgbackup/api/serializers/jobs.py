# Python
import logging
from collections import OrderedDict

# Django
from django.utils.timezone import now
from django.utils.translation import gettext_lazy as _
# Django REST Framework
from rest_framework import serializers

from cyborgbackup.main.constants import ACTIVE_STATES, ANSI_SGR_PATTERN
from cyborgbackup.main.models.jobs import Job, JobEvent
# CyBorgBackup
from .base import BaseSerializer, DynamicFieldsSerializerMixin

logger = logging.getLogger('cyborgbackup.api.serializers.jobs')


class JobSerializer(BaseSerializer):
    show_capabilities = ['start', 'delete']
    event_processing_finished = serializers.BooleanField(
        help_text=_('Indicates whether all of the events generated by this '
                    'unified job have been saved to the database.'),
        read_only=True
    )

    class Meta:
        model = Job
        fields = ('*', 'launch_type', 'status', 'policy',
                  'failed', 'started', 'finished', 'elapsed', 'job_args',
                  'original_size', 'compressed_size', 'deduplicated_size', 'archive_name',
                  'job_cwd', 'job_env', 'job_explanation', 'client', 'repository', 'master_job',
                  'dependent_jobs', 'result_traceback', 'event_processing_finished', 'job_type')

    def get_types(self):
        return ['job']

    def get_summary_fields(self, obj):
        summary_dict = super(JobSerializer, self).get_summary_fields(obj)
        if obj.policy and obj.policy.repository_id:
            summary_dict['repository'] = {
                'id': obj.policy.repository_id,
                'name': obj.policy.repository.name
            }

        if obj.policy and obj.policy.schedule_id:
            summary_dict['schedule'] = {
                'id': obj.policy.schedule_id,
                'name': obj.policy.schedule.name
            }

        return summary_dict

    def get_related(self, obj):
        res = super(JobSerializer, self).get_related(obj)
        res.update(dict(
            job_events=self.reverse('api:job_job_events_list', kwargs={'pk': obj.pk}),
        ))
        if obj.policy_id:
            res['policy'] = self.reverse('api:policy_detail', kwargs={'pk': obj.policy_id})
        res['stdout'] = self.reverse('api:job_stdout', kwargs={'pk': obj.pk})
        if obj.can_start or True:
            res['start'] = self.reverse('api:job_start', kwargs={'pk': obj.pk})
        if obj.can_cancel or True:
            res['cancel'] = self.reverse('api:job_cancel', kwargs={'pk': obj.pk})
        res['relaunch'] = self.reverse('api:job_relaunch', kwargs={'pk': obj.pk})
        return res

    def get_artifacts(self, obj):
        if obj:
            return obj.display_artifacts()
        return {}

    def to_internal_value(self, data):
        return super(JobSerializer, self).to_internal_value(data)

    def to_representation(self, obj):
        ret = super(JobSerializer, self).to_representation(obj)

        if 'elapsed' in ret:
            if obj and obj.pk and obj.started and not obj.finished:
                td = now() - obj.started
                ret['elapsed'] = (td.microseconds + (td.seconds + td.days * 24 * 3600) * 10 ** 6) / (10 ** 6 * 1.0)
            ret['elapsed'] = float(ret['elapsed'])

        return ret


class JobStdoutSerializer(JobSerializer):
    result_stdout = serializers.SerializerMethodField()

    class Meta:
        fields = ('result_stdout',)

    def get_types(self):
        return ['job']


class JobCancelSerializer(JobSerializer):
    can_cancel = serializers.BooleanField(read_only=True)

    class Meta:
        fields = ('can_cancel',)


class JobRelaunchSerializer(BaseSerializer):
    retry_counts = serializers.SerializerMethodField()

    class Meta:
        model = Job
        fields = ('retry_counts',)

    def get_retry_counts(self, obj):
        if obj.status in ACTIVE_STATES:
            return _('Relaunch by host status not available until job finishes running.')
        data = OrderedDict([])
        return data

    def get_validation_exclusions(self, *args, **kwargs):
        r = super(JobRelaunchSerializer, self).get_validation_exclusions(*args, **kwargs)
        return r

    def validate(self, attrs):
        attrs = super(JobRelaunchSerializer, self).validate(attrs)
        return attrs


class JobListSerializer(DynamicFieldsSerializerMixin, JobSerializer):
    class Meta:
        fields = ('*', '-job_args', '-job_cwd', '-job_env', '-result_traceback', '-event_processing_finished')

    def get_field_names(self, declared_fields, info):
        field_names = super(JobListSerializer, self).get_field_names(declared_fields, info)
        # Meta multiple inheritance and -field_name options don't seem to be
        # taking effect above, so remove the undesired fields here.
        return tuple(x for x in field_names if x not in (
            'job_args', 'job_cwd',
            'job_env', 'result_traceback', 'event_processing_finished'
        ))

    def get_types(self):
        return ['job']

    def to_representation(self, obj):
        serializer_class = None
        if type(self) is JobListSerializer:
            if isinstance(obj, Job):
                serializer_class = JobSerializer
        if serializer_class:
            serializer = serializer_class(instance=obj, context=self.context)
            ret = serializer.to_representation(obj)
        else:
            ret = super(JobListSerializer, self).to_representation(obj)
        if 'elapsed' in ret:
            ret['elapsed'] = float(ret['elapsed'])
        return ret


class JobEventSerializer(BaseSerializer):
    event_display = serializers.CharField(source='get_event_display2', read_only=True)
    event_level = serializers.IntegerField(read_only=True)

    class Meta:
        model = JobEvent
        fields = ('*', '-name', '-description', 'job', 'event', 'counter',
                  'event_display', 'event_data', 'event_level', 'failed',
                  'changed', 'uuid', 'task', 'stdout', 'start_line', 'end_line',
                  'verbosity', '-created_by', '-modified_by')

    def get_related(self, obj):
        res = super(JobEventSerializer, self).get_related(obj)
        res.update(dict(
            job=self.reverse('api:job_detail', kwargs={'pk': obj.job_id}),
        ))
        return res

    def get_summary_fields(self, obj):
        d = super(JobEventSerializer, self).get_summary_fields(obj)
        return d

    def to_representation(self, obj):
        ret = super(JobEventSerializer, self).to_representation(obj)
        # Show full stdout for event detail view, truncate only for list view.
        if hasattr(self.context.get('view', None), 'retrieve'):
            return ret
        # Show full stdout for playbook_on_* events.
        if obj and obj.event.startswith('playbook_on'):
            return ret
        max_bytes = 1024
        if 0 < max_bytes <= len(ret['stdout']) and 'stdout' in ret:
            ret['stdout'] = ret['stdout'][:(max_bytes - 1)] + u'\u2026'
            set_count = 0
            reset_count = 0
            for m in ANSI_SGR_PATTERN.finditer(ret['stdout']):
                if m.string[m.start():m.end()] == u'\u001b[0m':
                    reset_count += 1
                else:
                    set_count += 1
            ret['stdout'] += u'\u001b[0m' * (set_count - reset_count)
        return ret


class JobEventWebSocketSerializer(JobEventSerializer):
    created = serializers.SerializerMethodField()
    modified = serializers.SerializerMethodField()
    event_name = serializers.CharField(source='event')
    group_name = serializers.SerializerMethodField()

    class Meta:
        model = JobEvent
        fields = ('*', 'event_name', 'group_name',)

    def get_created(self, obj):
        return obj.created.isoformat()

    def get_modified(self, obj):
        return obj.modified.isoformat()

    def get_group_name(self, obj):
        return 'job_events'
